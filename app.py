from flask import Flask, request, jsonify
from flask_cors import CORS
import requests
import os
import logging
import sys
import json
import uuid
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor
from threading import Thread
import time
from dotenv import load_dotenv
import psycopg2
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart


# Configuration
load_dotenv()
db_url = os.getenv('DATABASE_URL')

# Logging
logger = logging.getLogger("buzzflix")
logger.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s')
file_handler = logging.FileHandler('/var/log/buzzflix.log')
file_handler.setFormatter(formatter)
logger.addHandler(file_handler)

app = Flask(__name__)
CORS(app)
executor = ThreadPoolExecutor(max_workers=10)

def get_db_connection():
    return psycopg2.connect(db_url)


class EmailNotifier:
    def __init__(self):
        logger.info("üìß Initialisation du syst√®me de notification email")
        self.sender_email = os.getenv('GMAIL_USER')
        self.sender_password = os.getenv('GMAIL_APP_PASSWORD')
        
        # Test de la connexion
        try:
            self._test_connection()
            logger.info("‚úÖ Configuration email valid√©e")
        except Exception as e:
            logger.error(f"""
            ‚ùå Erreur de configuration email:
            ‚îú‚îÄ‚îÄ Type: {type(e).__name__}
            ‚îî‚îÄ‚îÄ Message: {str(e)}
            """)

    def _test_connection(self):
        """Teste la connexion SMTP"""
        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
            server.login(self.sender_email, self.sender_password)

    def send_video_notification(self, video_info: dict):
        """Envoie une notification pour une nouvelle vid√©o"""
        try:
            logger.info(f"üìß Envoi de notification pour video_id: {video_info.get('video_id')}")
            
            # Cr√©ation du message
            message = MIMEMultipart()
            message["From"] = self.sender_email
            message["To"] = video_info['user_email']
            message["Subject"] = f"Nouvelle vid√©o Buzzflix cr√©√©e : {video_info.get('theme', 'Sans titre')}"

            # Corps du message
            body = f"""
            <html>
                <body>
                    <h2>üé• Nouvelle vid√©o cr√©√©e</h2>
                    <p>Votre nouvelle vid√©o a √©t√© g√©n√©r√©e avec succ√®s !</p>
                    
                    <h3>üìù D√©tails :</h3>
                    <ul>
                        <li><strong>Th√®me :</strong> {video_info.get('theme', 'N/A')}</li>
                        <li><strong>Langue :</strong> {video_info.get('language', 'N/A')}</li>
                        <li><strong>Destination :</strong> {video_info.get('destination', 'N/A')}</li>
                    </ul>

                    <p>Statut : ‚úÖ Compl√©t√©</p>
                    
                    <hr>
                    <p style="color: gray; font-size: 12px;">
                        Ceci est un message automatique de Buzzflix.
                        Ne pas r√©pondre √† cet email.
                    </p>
                </body>
            </html>
            """

            message.attach(MIMEText(body, "html"))

            # Envoi du message
            with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
                server.login(self.sender_email, self.sender_password)
                server.send_message(message)

            logger.info(f"""
            ‚úÖ Notification envoy√©e:
            ‚îú‚îÄ‚îÄ Video ID: {video_info.get('video_id')}
            ‚îú‚îÄ‚îÄ User Email: {video_info['user_email']}
            ‚îî‚îÄ‚îÄ Theme: {video_info.get('theme')}
            """)

        except Exception as e:
            logger.error(f"""
            ‚ùå Erreur d'envoi de notification:
            ‚îú‚îÄ‚îÄ Type: {type(e).__name__}
            ‚îú‚îÄ‚îÄ Message: {str(e)}
            ‚îî‚îÄ‚îÄ Video ID: {video_info.get('video_id')}
            """)


class VideoAutoScheduler:
    def __init__(self):
        logger.info("üöÄ D√©marrage du VideoAutoScheduler")
        self.worker = Thread(target=self.check_and_create_videos, daemon=True)
        self.worker.start()
        logger.info("‚úÖ Thread de surveillance d√©marr√©")

    def trigger_lambda(self, payload):
        """D√©clenche Lambda et envoie une notification email"""
        try:
            logger.info(f"""
            üöÄ Envoi √† Lambda:
            ‚îú‚îÄ‚îÄ Video ID: {payload['video_id']}
            ‚îú‚îÄ‚îÄ Series ID: {payload['series_id']}
            ‚îî‚îÄ‚îÄ Theme: {payload['theme']}
            """)

            # Appel Lambda dans son propre try
            try:
                response = requests.post(
                    os.getenv('AWS_LAMBDA_ENDPOINT'),
                    json=payload,
                    headers={'Content-Type': 'application/json'},
                    timeout=1
                )
                logger.info("‚úÖ Lambda d√©clench√© avec succ√®s")
            except requests.exceptions.Timeout:
                logger.info("‚è±Ô∏è Lambda timeout (normal)")
            
            # Partie email ind√©pendante de Lambda
            logger.info("üìß Pr√©paration de la notification email...")
            conn = get_db_connection()
            cur = conn.cursor()
            
            try:
                cur.execute("""
                    SELECT u.email
                    FROM "User" u
                    JOIN "Series" s ON s."userId" = u.id
                    WHERE s.id = %s
                """, (payload['series_id'],))
                
                result = cur.fetchone()
                if result is None:
                    logger.error("‚ùå Email utilisateur non trouv√©")
                    return
                    
                user_email = result[0]
                logger.info(f"üìß Email trouv√©: {user_email}")

                # Pr√©parer les infos pour la notification
                video_info = {
                    'video_id': payload['video_id'],
                    'series_id': payload['series_id'],
                    'theme': payload['theme'],
                    'language': payload['language'],
                    'destination': payload['destination'],
                    'user_email': user_email
                }

                # Envoyer la notification
                email_notifier.send_video_notification(video_info)
                logger.info("‚úÖ Email de notification envoy√©")

            except Exception as e:
                logger.error(f"""
                ‚ùå Erreur lors de l'envoi de l'email:
                ‚îú‚îÄ‚îÄ Type: {type(e).__name__}
                ‚îú‚îÄ‚îÄ Message: {str(e)}
                ‚îî‚îÄ‚îÄ Video ID: {payload['video_id']}
                """)
            finally:
                cur.close()
                conn.close()

        except Exception as e:
            logger.error(f"""
            ‚ùå Erreur g√©n√©rale dans trigger_lambda:
            ‚îú‚îÄ‚îÄ Video ID: {payload['video_id']}
            ‚îú‚îÄ‚îÄ Type: {type(e).__name__}
            ‚îî‚îÄ‚îÄ Message: {str(e)}
            """)
    def check_and_create_videos(self):
        """V√©rifie p√©riodiquement les s√©ries qui ont besoin d'une nouvelle vid√©o"""
        while True:
            try:
                conn = get_db_connection()
                cur = conn.cursor()
                logger.info("üîç Recherche des s√©ries actives...")

                cur.execute("""
                    SELECT 
                        s.id, s."userId", s.theme, s."destinationType",
                        s."destinationId", s."destinationEmail",
                        s.voice, s.language, s."durationRange", s.frequency,
                        p.name as plan_name,
                        COALESCE(MAX(v."createdAt"), s."createdAt") as last_video_date
                    FROM "Series" s
                    JOIN "User" u ON s."userId" = u.id
                    JOIN "Subscription" sub ON u.id = sub."userId"
                    JOIN "Plan" p ON sub."planId" = p.id
                    LEFT JOIN "Video" v ON s.id = v."seriesId"
                    WHERE s.status = 'active'
                    AND sub.status = 'active'
                    GROUP BY s.id, p.name
                """)
                
                series_list = cur.fetchall()
                logger.info(f"üìä Trouv√© {len(series_list)} s√©ries actives")
                current_time = datetime.utcnow()
                for series in series_list:
                    (series_id, user_id, theme, dest_type, dest_id, dest_email, 
                     voice, language, duration_range, frequency, plan_name, last_video_date) = series

                    logger.info(f"""
                    üìù Analyse de la s√©rie {series_id}:
                    ‚îú‚îÄ‚îÄ Plan: {plan_name}
                    ‚îú‚îÄ‚îÄ Derni√®re vid√©o: {last_video_date}
                    ‚îî‚îÄ‚îÄ Fr√©quence: {frequency} vid√©os/semaine
                    """)

                    # Calculer quand la prochaine vid√©o devrait √™tre cr√©√©e
                    days_between = 7 / frequency
                    next_video_date = last_video_date + timedelta(days=days_between)

                    if current_time >= next_video_date:
                        # V√©rifier d'abord s'il n'y a pas d√©j√† une vid√©o en cours
                        cur.execute("""
                            SELECT COUNT(*) FROM "Video"
                            WHERE "seriesId" = %s AND status = 'pending'
                        """, (series_id,))
                        
                        pending_count = cur.fetchone()[0]
                        
                        if pending_count == 0:
                            logger.info(f"‚ö° Cr√©ation d'une nouvelle vid√©o pour {series_id}")
                            
                            # Cr√©er une nouvelle vid√©o
                            video_id = str(uuid.uuid4())
                            cur.execute("""
                                INSERT INTO "Video" (id, "seriesId", status, "createdAt", "updatedAt")
                                VALUES (%s, %s, 'pending', %s, %s)
                            """, (video_id, series_id, current_time, current_time))

                            conn.commit()
                            logger.info(f"üíæ Vid√©o cr√©√©e: {video_id}")

                            # D√©clencher Lambda imm√©diatement
                            lambda_payload = {
                                'user_id': user_id,
                                'series_id': series_id,
                                'video_id': video_id,
                                'destination': dest_type,
                                'destination_id': dest_id,
                                'destination_email': dest_email,
                                'theme': theme,
                                'voice': voice,
                                'language': language,
                                'duration_range': duration_range
                            }
                            
                            self.trigger_lambda(lambda_payload)
                            
                            logger.info(f"""
                            ‚úÖ Nouvelle vid√©o trait√©e:
                            ‚îú‚îÄ‚îÄ Video ID: {video_id}
                            ‚îú‚îÄ‚îÄ Series ID: {series_id}
                            ‚îî‚îÄ‚îÄ Prochaine v√©rification dans: {days_between} jours
                            """)
                        else:
                            logger.info(f"‚è≥ Vid√©o d√©j√† en cours pour {series_id}")
                    else:
                        time_to_next = next_video_date - current_time
                        logger.info(f"‚åõ Trop t√¥t pour {series_id}, prochaine vid√©o dans {time_to_next}")

                logger.info("‚úÖ Cycle de v√©rification termin√©")

            except Exception as e:
                logger.error(f"""
                ‚ùå Erreur dans le scheduler:
                ‚îú‚îÄ‚îÄ Type: {type(e).__name__}
                ‚îî‚îÄ‚îÄ Message: {str(e)}
                """, exc_info=True)
            finally:
                if 'cur' in locals():
                    cur.close()
                if 'conn' in locals():
                    conn.close()
            
            logger.info("üí§ Pause de 5 minutes...")
            time.sleep(300)





class TikTokTokenRefresher:
    def __init__(self):
        logger.info("üîÑ D√©marrage du TikTokTokenRefresher")
        self.client_key = os.getenv('AUTH_TIKTOK_ID')
        self.client_secret = os.getenv('AUTH_TIKTOK_SECRET')
        self.worker = Thread(target=self.refresh_tokens_loop, daemon=True)
        self.worker.start()
        logger.info("‚úÖ Thread de refresh des tokens d√©marr√©")

    def refresh_token(self, refresh_token: str) -> dict:
        """Rafra√Æchit un token TikTok"""
        try:
            logger.info("üîÑ Tentative de rafra√Æchissement du token")
            
            response = requests.post(
                "https://open.tiktokapis.com/v2/oauth/token/",
                headers={"Content-Type": "application/x-www-form-urlencoded"},
                data={
                    "client_key": self.client_key,
                    "client_secret": self.client_secret,
                    "grant_type": "refresh_token",
                    "refresh_token": refresh_token
                }
            )
            
            if not response.ok:
                logger.error(f"""
                ‚ùå Erreur de rafra√Æchissement:
                ‚îú‚îÄ‚îÄ Status: {response.status_code}
                ‚îî‚îÄ‚îÄ Response: {response.text}
                """)
                return None

            data = response.json()
            logger.info("‚úÖ Token rafra√Æchi avec succ√®s")
            return {
                'access_token': data['access_token'],
                'refresh_token': data.get('refresh_token', refresh_token),
                'expires_in': data.get('expires_in', 86400)
            }
            
        except Exception as e:
            logger.error(f"""
            ‚ùå Erreur lors du rafra√Æchissement:
            ‚îú‚îÄ‚îÄ Type: {type(e).__name__}
            ‚îî‚îÄ‚îÄ Message: {str(e)}
            """)
            return None

    def refresh_tokens_loop(self):
        """Boucle principale de rafra√Æchissement des tokens"""
        while True:
            try:
                conn = get_db_connection()
                cur = conn.cursor()
                
                logger.info("üîç Recherche des comptes TikTok √† rafra√Æchir...")
                
                # Chercher les comptes dont le token expire dans moins de 6 heures
                cur.execute("""
                    SELECT 
                        id, "userId", "refreshToken", "tokenExpiresAt"
                    FROM "SocialAccount"
                    WHERE platform = 'TIKTOK'
                    AND "tokenExpiresAt" IS NOT NULL
                """)
                
                accounts = cur.fetchall()
                logger.info(f"üìä Trouv√© {len(accounts)} comptes √† rafra√Æchir")

                for account in accounts:
                    account_id, user_id, refresh_token, expires_at = account
                    
                    logger.info(f"""
                    üîÑ Traitement du compte:
                    ‚îú‚îÄ‚îÄ Account ID: {account_id}
                    ‚îú‚îÄ‚îÄ User ID: {user_id}
                    ‚îî‚îÄ‚îÄ Expiration: {expires_at}
                    """)

                    if not refresh_token:
                        logger.error(f"‚ùå Pas de refresh token pour {account_id}")
                        continue

                    # Rafra√Æchir le token
                    new_tokens = self.refresh_token(refresh_token)
                    if new_tokens:
                        new_expires_at = datetime.utcnow() + timedelta(seconds=new_tokens['expires_in'])
                        
                        # Mettre √† jour la base de donn√©es
                        cur.execute("""
                            UPDATE "SocialAccount"
                            SET 
                                "accessToken" = %s,
                                "refreshToken" = %s,
                                "tokenExpiresAt" = %s,
                                "updatedAt" = %s
                            WHERE id = %s
                        """, (
                            new_tokens['access_token'],
                            new_tokens['refresh_token'],
                            new_expires_at,
                            datetime.utcnow(),
                            account_id
                        ))
                        
                        conn.commit()
                        logger.info(f"""
                        ‚úÖ Token mis √† jour:
                        ‚îú‚îÄ‚îÄ Account ID: {account_id}
                        ‚îî‚îÄ‚îÄ Nouvelle expiration: {new_expires_at}
                        """)
                    else:
                        logger.error(f"‚ùå √âchec du rafra√Æchissement pour {account_id}")

                cur.close()
                conn.close()

            except Exception as e:
                logger.error(f"""
                ‚ùå Erreur dans la boucle de rafra√Æchissement:
                ‚îú‚îÄ‚îÄ Type: {type(e).__name__}
                ‚îî‚îÄ‚îÄ Message: {str(e)}
                """)
            
            # V√©rifier toutes les heures
            logger.info("üí§ Pause de 1 heure avant prochaine v√©rification...")
            time.sleep(3600)


# initialisation de l'application
token_refresher = TikTokTokenRefresher()

# Initialiser l'auto-scheduler au d√©marrage
video_scheduler = VideoAutoScheduler()

# Initialiser le notifieur
email_notifier = EmailNotifier()


@app.route('/create_series', methods=['POST'])
def create_series():
    try:
        data = request.json
        series_id = data.get('series_id')
        video_id = data.get('video_id')  # On s'attend √† recevoir l'ID de la vid√©o cr√©√©e par Next.js
        
        logger.info(f"""
        üì® Nouvelle requ√™te create_series:
        ‚îú‚îÄ‚îÄ Series ID: {series_id}
        ‚îî‚îÄ‚îÄ Video ID: {video_id}
        """)

        conn = get_db_connection()
        cur = conn.cursor()

        try:
            # V√©rifier que la vid√©o existe et est en statut pending
            cur.execute("""
                SELECT 
                    s."userId", s.theme, s."destinationType", s."destinationId",
                    s."destinationEmail", s.voice, s.language, s."durationRange",
                    v.status
                FROM "Video" v
                JOIN "Series" s ON v."seriesId" = s.id
                WHERE v.id = %s AND s.id = %s
            """, (video_id, series_id))
            
            video = cur.fetchone()
            
            if not video:
                logger.error(f"""
                ‚ùå Vid√©o non trouv√©e:
                ‚îú‚îÄ‚îÄ Series ID: {series_id}
                ‚îî‚îÄ‚îÄ Video ID: {video_id}
                """)
                return jsonify({
                    'status': 'error',
                    'message': 'Video not found'
                }), 404

            if video[8] != 'pending':
                logger.error(f"‚ùå La vid√©o {video_id} n'est pas en statut pending")
                return jsonify({
                    'status': 'error',
                    'message': 'Video not in pending status'
                }), 400

            logger.info(f"""
            ‚úÖ Vid√©o trouv√©e:
            ‚îú‚îÄ‚îÄ Video ID: {video_id}
            ‚îú‚îÄ‚îÄ Series ID: {series_id}
            ‚îú‚îÄ‚îÄ Theme: {video[1]}
            ‚îî‚îÄ‚îÄ Status: {video[8]}
            """)

            # D√©clencher Lambda
            lambda_payload = {
                'user_id': video[0],
                'series_id': series_id,
                'video_id': video_id,
                'destination': video[2],
                'destination_id': video[3],
                'destination_email': video[4],
                'theme': video[1],
                'voice': video[5],
                'language': video[6],
                'duration_range': video[7]
            }

            video_scheduler.trigger_lambda(lambda_payload)

            logger.info(f"""
            ‚úÖ Traitement initi√©:
            ‚îú‚îÄ‚îÄ Series ID: {series_id}
            ‚îú‚îÄ‚îÄ Video ID: {video_id}
            ‚îî‚îÄ‚îÄ Lambda: d√©clench√©
            """)

            return jsonify({
                'status': 'success',
                'message': 'Video generation started',
                'data': {
                    'video_id': video_id,
                    'series_id': series_id
                }
            })

        finally:
            cur.close()
            conn.close()

    except Exception as e:
        logger.error(f"""
        ‚ùå Erreur dans create_series:
        ‚îú‚îÄ‚îÄ Type: {type(e).__name__}
        ‚îú‚îÄ‚îÄ Message: {str(e)}
        ‚îú‚îÄ‚îÄ Series ID: {series_id if 'series_id' in locals() else 'N/A'}
        ‚îî‚îÄ‚îÄ Video ID: {video_id if 'video_id' in locals() else 'N/A'}
        """, exc_info=True)
        
        return jsonify({
            'status': 'error',
            'message': 'Internal server error'
        }), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)